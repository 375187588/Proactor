/**
 * \file CompletionEventQueue.hpp
 * \author Ronald T. Fernandez
 * \version 1.0
 * \brief Defines the hook method for processing the completion event (asynchronous operation)
 * generated by asynchronous operation.
 */

#ifndef COMPLETIONEVENTQUEUE_COMPLETIONEVENTQUEUE_HPP_
#define COMPLETIONEVENTQUEUE_COMPLETIONEVENTQUEUE_HPP_

#include <unordered_map>
#include <memory>
#include <mutex>
#include <utility>

#include "../asyncOperation/AsynchronousOperation.hpp"

using namespace proactor::asyncOperation;

namespace proactor {
namespace completionEventQueue {

template <typename T>
class CompletionEventQueue : public std::unordered_map<AsynchronousOperation<T>*, const unsigned int> {
private:
	std::mutex m;
public:
	CompletionEventQueue() : std::unordered_map<AsynchronousOperation<T>*, const unsigned int >() {};
	virtual ~CompletionEventQueue() {
		this->erase(this->begin(), this->end());
	};
	std::pair<AsynchronousOperation<T>*, const unsigned int> pop() {
		std::unique_lock<std::mutex> locker(m);
		typedef typename std::unordered_map<AsynchronousOperation<T>*, const unsigned int>::iterator iterType;
		iterType it = this->begin();
		std::pair<AsynchronousOperation<T>*, const unsigned int> p = std::make_pair(it->first, it->second);
		this->erase(it->first);
		return p;
	}
	void push(AsynchronousOperation<T> *operation, const unsigned int id) {
		std::unique_lock<std::mutex> locker(m);
		this->insert(std::pair<AsynchronousOperation<T>*, int>(operation, id));
	};
};

}
}

#endif /* COMPLETIONEVENTQUEUE_COMPLETIONEVENTQUEUE_HPP_ */
