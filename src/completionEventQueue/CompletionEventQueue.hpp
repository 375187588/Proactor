/**
 * \file CompletionEventQueue.hpp
 * \author Ronald T. Fernandez
 * \version 1.0
 * \brief Defines the hook method for processing the completion event (asynchronous operation)
 * generated by asynchronous operation.
 */

#ifndef COMPLETIONEVENTQUEUE_COMPLETIONEVENTQUEUE_HPP_
#define COMPLETIONEVENTQUEUE_COMPLETIONEVENTQUEUE_HPP_

#include <unordered_map>
#include <memory>
#include <mutex>
#include <utility>

#include "../asyncOperation/AsynchronousOperation.hpp"

namespace proactor {
namespace completionEventQueue {

/**
 * This class defines the "list" (actually, it is a map) of completed events.
 */
template <typename T>
class CompletionEventQueue : private  std::unordered_map<asyncOperation::AsynchronousOperation<T>*, const unsigned int> {
private:
	/**
	 * Lock to push and pop events in the list
	 */
	std::mutex mutex;
public:
	/**
	 * Class constructor
	 */
	CompletionEventQueue() : std::unordered_map<asyncOperation::AsynchronousOperation<T>*, const unsigned int >() {
	};

	/**
	 * Class destructor
	 */
	virtual ~CompletionEventQueue() {
		this->clear();
	};

	/**
	 * Pop an operation from the completion list and remove it from the list
	 * @return An operation from the completion list
	 */
	std::pair<asyncOperation::AsynchronousOperation<T>*, const unsigned int> pop() {
		// Lock the map insertion/deletion
		std::lock_guard<std::mutex> locker(mutex);
		typedef typename std::unordered_map<asyncOperation::AsynchronousOperation<T>*, const unsigned int>::iterator iterType;
		iterType it = this->begin();
		std::pair<asyncOperation::AsynchronousOperation<T>*, const unsigned int> p = std::make_pair(it->first, it->second);
		this->erase(it->first);
		return p;
	}
	void push(asyncOperation::AsynchronousOperation<T> *operation, const unsigned int id) {
		std::lock_guard<std::mutex> locker(mutex);
		this->insert(std::pair<asyncOperation::AsynchronousOperation<T>*, int>(operation, id));
	};

	const size_t size() {
		std::lock_guard<std::mutex> locker(mutex);
		return std::unordered_map<asyncOperation::AsynchronousOperation<T>*, const unsigned int>::size();
	}
};

}
}

#endif /* COMPLETIONEVENTQUEUE_COMPLETIONEVENTQUEUE_HPP_ */
